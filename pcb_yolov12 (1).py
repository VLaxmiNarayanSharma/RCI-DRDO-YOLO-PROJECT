# -*- coding: utf-8 -*-
"""PCB_YOLOV12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12rhyiRBG6sDeANU4vZo6Lh2tHR-f8Viu
"""

# Mount Google Drive if needed
from google.colab import drive
drive.mount('/content/drive')

# Install required packages
!pip install -q kaggle ultralytics

# Upload your Kaggle API token
from google.colab import files
files.upload()  # Upload kaggle.json

# Move kaggle.json to proper location
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

# Download and extract PCB Defects dataset
!kaggle datasets download -d akhatova/pcb-defects -p /content
!unzip -q /content/pcb-defects.zip -d /content/pcb-defects

!conda create -n yolov12_env python=3.10 -y
!conda activate yolov12_env

import os, shutil, random, xml.etree.ElementTree as ET
from glob import glob

root_dir = "/content/pcb-defects"
all_xmls = glob(os.path.join(root_dir, "**", "*.xml"), recursive=True)
all_images = glob(os.path.join(root_dir, "**", "*.*"), recursive=True)
all_images = [f for f in all_images if f.lower().endswith(('.jpg', '.jpeg', '.png'))]

image_map = {os.path.splitext(os.path.basename(p))[0]: p for p in all_images}

# Create YOLO folders
base_yolo = "/content/pcb_defects_yolo"
for split in ["train", "val"]:
    os.makedirs(os.path.join(base_yolo, f"images/{split}"), exist_ok=True)
    os.makedirs(os.path.join(base_yolo, f"labels/{split}"), exist_ok=True)

# Class list
classes = ['missing_hole','mouse_bite','open_circuit','short','spur','spurious_copper']

# Shuffle and split
random.shuffle(all_xmls)
split_idx = int(0.8 * len(all_xmls))
train_xmls = all_xmls[:split_idx]
val_xmls = all_xmls[split_idx:]

def convert(xmls, split):
    for xml in xmls:
        base = os.path.splitext(os.path.basename(xml))[0]
        image_path = image_map.get(base)
        if not image_path: continue

        # Copy image
        shutil.copy(image_path, os.path.join(base_yolo, f"images/{split}", os.path.basename(image_path)))

        # Convert annotation
        tree = ET.parse(xml)
        root = tree.getroot()
        w = float(root.find('size/width').text)
        h = float(root.find('size/height').text)
        label_path = os.path.join(base_yolo, f"labels/{split}", base + '.txt')
        with open(label_path, 'w') as f:
            for obj in root.iter('object'):
                cls = obj.find('name').text.lower()
                if cls not in classes: continue
                cid = classes.index(cls)
                b = obj.find('bndbox')
                xmin, ymin = float(b.find('xmin').text), float(b.find('ymin').text)
                xmax, ymax = float(b.find('xmax').text), float(b.find('ymax').text)
                x_c = ((xmin+xmax)/2)/w
                y_c = ((ymin+ymax)/2)/h
                bw = (xmax - xmin)/w
                bh = (ymax - ymin)/h
                f.write(f"{cid} {x_c:.6f} {y_c:.6f} {bw:.6f} {bh:.6f}\n")

convert(train_xmls, "train")
convert(val_xmls, "val")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile pcb.yaml
# path: /content/pcb_defects_yolo
# train: images/train
# val: images/val
# 
# nc: 6
# names: ['missing_hole', 'mouse_bite', 'open_circuit', 'short', 'spur', 'spurious_copper']
#

from ultralytics import YOLO

# Use yolov8n.pt temporarily if yolo12n.pt is not available
model = YOLO("yolo12n.pt")

results = model.train(
    data="pcb.yaml",
    epochs=60,
    imgsz=640,
    batch=16,
    lr0=0.002
)

from ultralytics import YOLO

# Load the previously trained weights (not resuming, just initializing from best.pt)
model = YOLO("/content/runs/detect/train/weights/best.pt")

# Start new training (will continue learning from where it left off)
results = model.train(
    data="pcb.yaml",
    epochs=50,         # extra epochs you want
    imgsz=640,
    batch=16,
    lr0=0.001,         # reduced LR for fine-tuning
    pretrained=True    # ensures it initializes with weights
)

from ultralytics import YOLO

# Load the previously trained weights (not resuming, just initializing from best.pt)
model = YOLO("/content/runs/detect/train6/weights/best.pt")

# Start new training (will continue learning from where it left off)
results = model.train(
    data="pcb.yaml",
    epochs=50,         # extra epochs you want
    imgsz=640,
    batch=16,
    lr0=0.001,         # reduced LR for fine-tuning
    pretrained=True    # ensures it initializes with weights
)

!pip freeze > requirements.txt

from ultralytics import YOLO

# Load YOLOv12 small model
model = YOLO("yolo12s.pt")

# Train for first 60 epochs
results = model.train(
    data="/content/pcb.yaml",    # Update path as needed
    epochs=60,
    imgsz=640,
    batch=16,
    lr0=0.002,
    name="pcb_yolov12s_1"
)

# Load the previously trained model
model = YOLO("/content/runs/detect/pcb_yolov12s_1/weights/best.pt")

# Resume training (total training now = 120 epochs)
results = model.train(
    data="/content/pcb.yaml",
    epochs=60,                      # This is *additional* to prior 60
    imgsz=640,
    batch=16,
    lr0=0.002,
    name="pcb_yolov12s_2",
    pretrained=True                 # ✅ Use pretrained=True to ensure weights are loaded
)

# Load the previously trained model
model = YOLO("/content/runs/detect/pcb_yolov12s_2/weights/best.pt")

# Resume training (total training now = 120 epochs)
results = model.train(
    data="/content/pcb.yaml",
    epochs=60,                      # This is *additional* to prior 60
    imgsz=640,
    batch=16,
    lr0=0.002,
    name="pcb_yolov12s_3",
    pretrained=True                 # ✅ Use pretrained=True to ensure weights are loaded
)

from ultralytics import YOLO

# Load the trained model
model = YOLO("/content/runs/detect/train7/weights/best.pt")  # Replace with the actual path to your best.pt file

# Specify the path to your test image
test_image_path = "/content/pcb_defects_yolo/images/val/06_short_07.jpg"  # Replace with the path to your image

# Run inference on the test image
results = model(test_image_path)

# Display the results
for r in results:
    r.show()

from ultralytics import YOLO

# Use yolov8n.pt temporarily if yolo12n.pt is not available
model = YOLO("yolo12m.pt")

results = model.train(
    data="pcb.yaml",
    epochs=60,
    imgsz=640,
    batch=32,
    lr0=0.002
)

from ultralytics import YOLO

# Load the trained model
model = YOLO("/content/runs/detect/train/weights/best.pt")  # Replace with the actual path to your best.pt file

# Specify the path to your test image
test_image_path = "/content/pcb-defects/images/01_missing_hole/missing_hole_01.jpg"  # Replace with the path to your image

# Run inference on the test image
results = model(test_image_path)

# Display the results
for r in results:
    r.show()

!pip install -q ultralytics # Ensure ultralytics is installed in this environment
from ultralytics import YOLO
from IPython.display import Image, display
import os

# 1️⃣ Load the trained YOLOv11 model (best checkpoint)
model_path = "/content/YOLOV12_best.pt"
model = YOLO(model_path)

print("✅ YOLOv11 model loaded!")

# 2️⃣ Evaluate the model on the validation set (uses val path from pcb.yaml)
metrics = model.val()